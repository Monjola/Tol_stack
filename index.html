<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>StackMaster | Tolerance Analysis</title>
    <style>
      :root {
        --bg: #0d1117;
        --bg-alt: #161b22;
        --card: #1d222b;
        --text: #e6edf3;
        --muted: #8b949e;
        --accent: #58a6ff;
        --border: #30363d;
        --danger: #ff7b72;
        --success: #3fb950;
        --warning: #f2cc60;
        --font: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: var(--bg);
        color: var(--text);
        font-family: var(--font);
        display: flex;
        flex-direction: column;
        padding: 1rem;
        gap: 1rem;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.5rem;
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 0.75rem;
      }

      header h1 {
        margin: 0;
        font-size: 1.5rem;
      }

      main {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        min-height: calc(100vh - 5rem);
      }

      section {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        display: flex;
        flex-direction: column;
        padding: 1rem;
        overflow: hidden;
      }

      #canvas-container {
        position: relative;
        gap: 0.75rem;
      }

      #canvas-container input[type="file"] {
        width: 100%;
        border: 1px dashed var(--border);
        padding: 0.75rem;
        border-radius: 0.5rem;
        background: var(--bg-alt);
        color: var(--text);
      }

      .canvas-wrapper {
        position: relative;
        width: 100%;
        flex: 1;
        border-radius: 0.5rem;
        overflow: hidden;
        border: 1px solid var(--border);
        background: var(--bg-alt);
        min-height: 320px;
      }

      #drawing-img,
      #drawing-canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      #drawing-canvas {
        pointer-events: auto;
      }

      .canvas-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.9rem;
        color: var(--muted);
      }

      /* Data grid */
      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 640px;
      }

      thead th {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--muted);
        text-align: left;
        border-bottom: 1px solid var(--border);
        padding-bottom: 0.35rem;
      }

      tbody td {
        padding: 0.5rem 0.25rem;
        border-bottom: 1px solid rgba(48, 54, 61, 0.6);
      }

      tbody input,
      tbody select {
        width: 100%;
        padding: 0.35rem 0.5rem;
        border-radius: 0.35rem;
        border: 1px solid var(--border);
        background: var(--bg-alt);
        color: var(--text);
        font-size: 0.9rem;
      }

      tbody input[type="checkbox"] {
        width: auto;
        accent-color: var(--accent);
      }

      .table-actions {
        display: flex;
        justify-content: flex-end;
        padding-top: 0.75rem;
        gap: 0.5rem;
      }

      button {
        background: var(--accent);
        color: #fff;
        border: none;
        border-radius: 0.5rem;
        padding: 0.5rem 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 150ms ease;
      }

      button.secondary {
        background: transparent;
        border: 1px solid var(--border);
        color: var(--text);
      }

      button:hover {
        background: #3d8ef5;
      }

      /* Dashboard */
      #dashboard {
        gap: 1rem;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.75rem;
      }

      .stat-card {
        background: var(--bg-alt);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        padding: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .stat-label {
        font-size: 0.8rem;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .stat-value {
        font-size: 1.3rem;
        font-weight: 600;
      }

      #pareto-chart {
        position: relative;
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        padding: 1rem;
        min-height: 320px;
        background: var(--bg-alt);
        overflow: hidden;
      }

      .pareto-bars {
        display: flex;
        align-items: flex-end;
        gap: 1rem;
        height: 220px;
      }

      .bar-container {
        flex: 1;
        min-width: 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.35rem;
      }

      .bar {
        width: 100%;
        min-height: 4px;
        height: 100%;
        border-radius: 0.5rem 0.5rem 0 0;
        background: var(--border);
        display: flex;
        align-items: flex-end;
        justify-content: center;
        overflow: hidden;
      }

      .bar-fill {
        width: 100%;
        background: var(--accent);
        border-radius: inherit;
      }

      .bar-label {
        font-size: 0.8rem;
        color: var(--muted);
        text-align: center;
      }

      .cumulative-line {
        position: absolute;
        inset: 1rem;
        pointer-events: none;
      }

      .cumulative-line polyline {
        fill: none;
        stroke: var(--warning);
        stroke-width: 2;
      }

      .cumulative-line circle {
        fill: var(--warning);
      }

      dialog {
        border: none;
        border-radius: 0.75rem;
        padding: 1.5rem;
        background: var(--card);
        color: var(--text);
        width: min(420px, 90vw);
      }

      dialog::backdrop {
        background: rgba(0, 0, 0, 0.55);
      }

      dialog form {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      dialog input {
        width: 100%;
        padding: 0.5rem;
        border-radius: 0.5rem;
        border: 1px solid var(--border);
        background: var(--bg-alt);
        color: var(--text);
      }

      @media (max-width: 1200px) {
        table {
          min-width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>StackMaster · Tolerance Analysis</h1>
      <button id="open-gdt-dialog" class="secondary">GD&amp;T Wizard</button>
    </header>

    <main>
      <section id="canvas-container">
        <h2>Visual Canvas</h2>
        <input type="file" id="drawing-upload" accept="image/*" />
        <div class="canvas-wrapper">
          <img id="drawing-img" alt="Drawing background" />
          <canvas id="drawing-canvas"></canvas>
        </div>
        <div class="canvas-controls">
          <span>Click = Balloon · Drag = Arrow</span>
          <button id="clear-annotations" class="secondary">Clear</button>
        </div>
      </section>

      <section id="data-grid">
        <h2>Stack Data</h2>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>Description</th>
                <th>Nominal</th>
                <th>Tolerance Type</th>
                <th>Tol (+/-)</th>
                <th>Cpk</th>
                <th>Float Shifted</th>
              </tr>
            </thead>
            <tbody id="stack-body"></tbody>
          </table>
        </div>
        <div class="table-actions">
          <button id="add-row">Add Row</button>
        </div>
      </section>

      <section id="dashboard">
        <h2>Dashboard</h2>
        <div class="stats-grid">
          <div class="stat-card">
            <span class="stat-label">Stack Mean</span>
            <span class="stat-value" id="stat-mean">0.000</span>
          </div>
          <div class="stat-card">
            <span class="stat-label">Stack Sigma</span>
            <span class="stat-value" id="stat-sigma">0.000</span>
          </div>
          <div class="stat-card">
            <span class="stat-label">3σ Range</span>
            <span class="stat-value" id="stat-3sigma">0.000</span>
          </div>
          <div class="stat-card">
            <span class="stat-label">6σ Range</span>
            <span class="stat-value" id="stat-6sigma">0.000</span>
          </div>
        </div>
        <h3>Pareto Contributions</h3>
        <div id="pareto-chart"></div>
      </section>
    </main>

    <dialog id="gdt-dialog">
      <form method="dialog">
        <h3>GD&amp;T Position @ MMC</h3>
        <label>
          Nominal
          <input type="number" step="0.001" id="gdt-nominal" />
        </label>
        <label>
          Tolerance
          <input type="number" step="0.001" id="gdt-tolerance" />
        </label>
        <label>
          Hole Max
          <input type="number" step="0.001" id="gdt-hole-max" />
        </label>
        <label>
          Hole Min
          <input type="number" step="0.001" id="gdt-hole-min" />
        </label>
        <div class="table-actions">
          <button value="cancel" class="secondary">Close</button>
        </div>
      </form>
    </dialog>

    <script>
      const stackData = [
        { description: "Dim 1", nominal: 10, tol: 0.1, tolType: "Linear", cpk: 1.33, floatShifted: false },
        { description: "Dim 2", nominal: 10, tol: 0.2, tolType: "Linear", cpk: 1.33, floatShifted: false },
        { description: "Dim 3", nominal: 10, tol: 0.3, tolType: "Linear", cpk: 1.33, floatShifted: false },
      ];
      const annotations = [];

      const state = {
        drawing: false,
        start: null,
        canvas: null,
        ctx: null,
        previewEnd: null,
      };

      document.addEventListener("DOMContentLoaded", () => {
        setupCanvas();
        setupTable();
        setupDashboard();
        setupGDTHelpers();
      });

      function setupCanvas() {
        const uploadInput = document.getElementById("drawing-upload");
        const img = document.getElementById("drawing-img");
        const canvas = document.getElementById("drawing-canvas");
        const clearBtn = document.getElementById("clear-annotations");

        state.canvas = canvas;
        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);

        canvas.addEventListener("pointerdown", handlePointerDown);
        canvas.addEventListener("pointermove", handlePointerMove);
        canvas.addEventListener("pointerup", handlePointerUp);
        canvas.addEventListener("pointerleave", handlePointerUp);

        uploadInput.addEventListener("change", (event) => {
          const file = event.target.files?.[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = () => {
            img.src = reader.result;
          };
          reader.readAsDataURL(file);
        });

        clearBtn.addEventListener("click", () => {
          annotations.length = 0;
          redrawAnnotations();
        });
      }

      function resizeCanvas() {
        if (!state.canvas) return;
        const rect = state.canvas.parentElement.getBoundingClientRect();
        state.canvas.width = rect.width;
        state.canvas.height = rect.height;
        state.canvas.style.width = `${rect.width}px`;
        state.canvas.style.height = `${rect.height}px`;
        state.ctx = state.canvas.getContext("2d");
        redrawAnnotations();
      }

      function redrawAnnotations() {
        if (!state.ctx) return;
        const ctx = state.ctx;
        ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
        ctx.lineWidth = 2;
        const strokeColor = "#58a6ff";
        const fillColor = "rgba(88,166,255,0.15)";
        ctx.strokeStyle = strokeColor;
        ctx.fillStyle = fillColor;

        annotations.forEach((entry, index) => {
          if (entry.type === "balloon") {
            drawBalloon(ctx, entry.x, entry.y, index + 1, strokeColor, fillColor);
          } else if (entry.type === "arrow") {
            drawArrow(ctx, entry.start, entry.end, strokeColor);
          }
        });

        if (state.previewEnd && state.start) {
          drawArrow(ctx, state.start, state.previewEnd, "rgba(88,166,255,0.5)");
        }
      }

      function drawBalloon(ctx, x, y, label, stroke, fill) {
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke;
        ctx.arc(x, y, 18, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = "#e6edf3";
        ctx.font = "14px 'Inter', 'Segoe UI', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(String(label), x, y);
        ctx.restore();
      }

      function drawArrow(ctx, start, end, color) {
        ctx.save();
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();

        const angle = Math.atan2(end.y - start.y, end.x - start.x);
        const headLength = 14;
        ctx.beginPath();
        ctx.moveTo(end.x, end.y);
        ctx.lineTo(end.x - headLength * Math.cos(angle - Math.PI / 6), end.y - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(end.x - headLength * Math.cos(angle + Math.PI / 6), end.y - headLength * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function handlePointerDown(event) {
        if (!state.canvas) return;
        const point = getCanvasPoint(event);
        state.drawing = true;
        state.start = point;
        state.previewEnd = null;
      }

      function handlePointerMove(event) {
        if (!state.drawing || !state.start) return;
        state.previewEnd = getCanvasPoint(event);
        redrawAnnotations();
      }

      function handlePointerUp(event) {
        if (!state.drawing || !state.start) {
          state.previewEnd = null;
          return;
        }

        const endPoint = getCanvasPoint(event);
        const distance = Math.hypot(endPoint.x - state.start.x, endPoint.y - state.start.y);

        if (distance < 6) {
          annotations.push({ type: "balloon", x: state.start.x, y: state.start.y });
        } else {
          annotations.push({ type: "arrow", start: { ...state.start }, end: endPoint });
        }

        state.drawing = false;
        state.start = null;
        state.previewEnd = null;
        redrawAnnotations();
      }

      function getCanvasPoint(event) {
        const rect = state.canvas.getBoundingClientRect();
        return {
          x: event.clientX - rect.left,
          y: event.clientY - rect.top,
        };
      }

      function setupTable() {
        document.getElementById("add-row").addEventListener("click", () => {
          stackData.push({
            description: "",
            nominal: 0,
            tol: 0,
            tolType: "Linear",
            cpk: 1.33,
            floatShifted: false,
          });
          renderTable();
        });
        renderTable();
      }

      function renderTable() {
        const tbody = document.getElementById("stack-body");
        tbody.innerHTML = "";

        stackData.forEach((row, index) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td><input type="text" data-key="description" data-index="${index}" value="${row.description ?? ""}"></td>
            <td><input type="number" step="0.001" data-key="nominal" data-index="${index}" value="${row.nominal ?? 0}"></td>
            <td>
              <select data-key="tolType" data-index="${index}">
                <option ${row.tolType === "Linear" ? "selected" : ""}>Linear</option>
                <option ${row.tolType === "GD&T" ? "selected" : ""}>GD&T</option>
                <option ${row.tolType === "Float" ? "selected" : ""}>Float</option>
              </select>
            </td>
            <td><input type="text" data-key="tol" data-index="${index}" value="${row.tol ?? 0}"></td>
            <td><input type="number" step="0.01" data-key="cpk" data-index="${index}" value="${row.cpk ?? 1.33}"></td>
            <td style="text-align:center;"><input type="checkbox" data-key="floatShifted" data-index="${index}" ${row.floatShifted ? "checked" : ""}></td>
          `;
          tbody.appendChild(tr);
        });

        tbody.querySelectorAll("input, select").forEach((input) => {
          input.addEventListener("input", handleCellInput);
        });
      }

      function handleCellInput(event) {
        const { index, key } = event.target.dataset;
        if (index === undefined || !key) return;

        if (event.target.type === "checkbox") {
          stackData[index][key] = event.target.checked;
        } else if (event.target.type === "number") {
          stackData[index][key] = parseFloat(event.target.value) || 0;
        } else {
          stackData[index][key] = event.target.value;
        }

        calculateStack();
      }

      function setupDashboard() {
        calculateStack();
      }

      function calculateStack() {
        let stackMean = 0;
        let stackVariance = 0;

        stackData.forEach((row) => {
          const { nominalAdj, tolAdj } = parseAsymmetry(row.tol, row.nominal);
          const cpk = row.cpk || 1.33;
          const rowSigma = tolAdj / (3 * cpk || 1);
          stackMean += nominalAdj;
          stackVariance += rowSigma ** 2;
        });

        const stackSigma = Math.sqrt(stackVariance);
        const range3 = `${(stackMean - 3 * stackSigma).toFixed(3)} / ${(stackMean + 3 * stackSigma).toFixed(3)}`;
        const range6 = `${(stackMean - 6 * stackSigma).toFixed(3)} / ${(stackMean + 6 * stackSigma).toFixed(3)}`;

        document.getElementById("stat-mean").textContent = stackMean.toFixed(3);
        document.getElementById("stat-sigma").textContent = stackSigma.toFixed(3);
        document.getElementById("stat-3sigma").textContent = range3;
        document.getElementById("stat-6sigma").textContent = range6;

        renderPareto(stackVariance);
        console.log({ stackMean, stackSigma, range3, range6 });
      }

      function parseAsymmetry(tol, nominal) {
        if (typeof tol === "number") {
          return {
            nominalAdj: nominal,
            tolAdj: Math.abs(tol),
          };
        }

        if (!tol) {
          return { nominalAdj: nominal, tolAdj: 0 };
        }

        const pattern = /([-+]?\d*\.?\d+)\s*([+-]\d*\.?\d+)\/([+-]\d*\.?\d+)/;
        const match = String(tol).trim().match(pattern);

        if (match) {
          const base = parseFloat(match[1]);
          const plus = parseFloat(match[2]);
          const minus = parseFloat(match[3]);
          const nominalAdj = base + (plus + minus) / 2;
          const tolAdj = Math.abs(plus) + Math.abs(minus);
          return { nominalAdj, tolAdj };
        }

        const numeric = parseFloat(tol);
        return {
          nominalAdj: nominal,
          tolAdj: isNaN(numeric) ? 0 : Math.abs(numeric),
        };
      }

      function renderPareto(totalVariance) {
        const container = document.getElementById("pareto-chart");
        container.innerHTML = "";

        if (!totalVariance || totalVariance === 0) {
          container.innerHTML = `<p class="bar-label">Add stack data to view Pareto contributions.</p>`;
          return;
        }

        const contributions = stackData.map((row) => {
          const { tolAdj } = parseAsymmetry(row.tol, row.nominal);
          const cpk = row.cpk || 1.33;
          const rowSigma = tolAdj / (3 * cpk || 1);
          const variance = rowSigma ** 2;
          return {
            description: row.description || "Unnamed",
            percent: (variance / totalVariance) * 100 || 0,
          };
        });

        const sorted = contributions.sort((a, b) => b.percent - a.percent);
        const barsWrap = document.createElement("div");
        barsWrap.className = "pareto-bars";

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", "0 0 100 100");
        svg.classList.add("cumulative-line");

        let cumulative = 0;
        const points = [];

        sorted.forEach((entry, index) => {
          const wrapper = document.createElement("div");
          wrapper.className = "bar-container";

          const bar = document.createElement("div");
          bar.className = "bar";

          const fill = document.createElement("div");
          fill.className = "bar-fill";
          fill.style.height = `${Math.min(entry.percent, 100)}%`;
          fill.style.background = entry.percent > 40 ? "var(--danger)" : "var(--accent)";

          const valueLabel = document.createElement("div");
          valueLabel.className = "bar-label";
          valueLabel.textContent = `${entry.description} · ${entry.percent.toFixed(1)}%`;

          bar.appendChild(fill);
          wrapper.append(bar, valueLabel);
          barsWrap.appendChild(wrapper);

          cumulative += entry.percent;
          const x = sorted.length === 1 ? 100 : (index / (sorted.length - 1)) * 100;
          const y = Math.max(0, 100 - Math.min(cumulative, 100));
          points.push(`${x},${y}`);

          const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          dot.setAttribute("cx", x);
          dot.setAttribute("cy", y);
          dot.setAttribute("r", 1.5);
          svg.appendChild(dot);
        });

        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        polyline.setAttribute("points", points.join(" "));
        svg.insertBefore(polyline, svg.firstChild);

        container.append(barsWrap, svg);
      }

      function setupGDTHelpers() {
        const dialog = document.getElementById("gdt-dialog");
        document.getElementById("open-gdt-dialog").addEventListener("click", () => {
          dialog.showModal();
        });
      }
    </script>
  </body>
</html>

